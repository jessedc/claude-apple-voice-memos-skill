#!/usr/bin/env python3
# SPDX-License-Identifier: 0BSD
# Copyright (c) 2025 Tomoki Aonuma
# Source: https://github.com/uasi/extract-apple-voice-memos-transcript

import argparse
import json
import struct
import sys


def read_atom_header(f):
    header = f.read(8)
    if len(header) < 8:
        return None, None, 0

    size = struct.unpack(">I", header[:4])[0]
    atom_type = header[4:8].decode("ascii", errors="ignore")

    if size == 1:
        extended_size = struct.unpack(">Q", f.read(8))[0]
        return atom_type, extended_size, 16

    return atom_type, size, 8


def find_atom(f, end_pos, target_type):
    while f.tell() < end_pos:
        current_pos = f.tell()
        atom_type, atom_size, header_size = read_atom_header(f)

        if atom_type is None or atom_size == 0:
            break

        atom_end = current_pos + atom_size

        if atom_type == target_type:
            return atom_end, header_size
        else:
            f.seek(atom_end)

    return None, None


def error_exit(message):
    print(message, file=sys.stderr)
    sys.exit(1)


def format_timestamp(seconds):
    """Format seconds into [H:MM:SS] or [M:SS] format."""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    
    if hours > 0:
        return f"[{hours}:{minutes:02d}:{secs:02d}]"
    else:
        return f"[{minutes}:{secs:02d}]"


def extract_text_with_timestamps(json_obj):
    """Extract text segments with their timestamps from the JSON object."""
    segments = []
    
    # Check if we have attributedString
    attributed_string = json_obj.get("attributedString")
    
    if isinstance(attributed_string, list):
        # Interleaved format: text and time attributes mixed in array
        current_time = 0
        for i, item in enumerate(attributed_string):
            if isinstance(item, str):
                # Look for the next item which might contain timeRange
                time_info = None
                if i + 1 < len(attributed_string) and isinstance(attributed_string[i + 1], dict):
                    time_range = attributed_string[i + 1].get("timeRange")
                    if time_range and isinstance(time_range, list) and len(time_range) >= 1:
                        current_time = time_range[0]
                        time_info = current_time
                
                if time_info is not None:
                    segments.append((time_info, item))
                elif segments:  # Use the last known time if no new time info
                    segments.append((current_time, item))
                else:
                    segments.append((0, item))
                    
    elif isinstance(attributed_string, dict):
        # Separated format: attributeTable contains time ranges, runs contains text
        runs = attributed_string.get("runs", [])
        attribute_table = attributed_string.get("attributeTable", [])
        
        current_time = 0
        for i in range(0, len(runs), 2):
            if i < len(runs):
                text = runs[i] if isinstance(runs[i], str) else ""
                
                # Get attribute index if available
                if i + 1 < len(runs) and isinstance(runs[i + 1], int):
                    attr_index = runs[i + 1]
                    # attributeTable is a list, use index directly
                    if isinstance(attribute_table, list) and 0 <= attr_index < len(attribute_table):
                        time_range = attribute_table[attr_index].get("timeRange")
                        if time_range and isinstance(time_range, list) and len(time_range) >= 1:
                            current_time = time_range[0]
                
                segments.append((current_time, text))
    
    if not segments:
        return ""
    
    # Group segments into lines - aggregate text that's close in time
    # Consider segments within 15 seconds as part of the same line
    lines = []
    current_line_time = segments[0][0]
    current_line_text = []
    
    for time, text in segments:
        if text.strip():
            # Start a new line if there's a significant time gap (> 15 seconds) or punctuation suggests a break
            if (time - current_line_time > 15 or 
                (current_line_text and current_line_text[-1].rstrip().endswith(('.', '!', '?')))):
                if current_line_text:
                    lines.append((current_line_time, ''.join(current_line_text)))
                current_line_time = time
                current_line_text = [text]
            else:
                current_line_text.append(text)
    
    # Add the last line
    if current_line_text:
        lines.append((current_line_time, ''.join(current_line_text)))
    
    # Check if we need hours format (if any timestamp >= 3600 seconds)
    max_time = max((t for t, _ in lines), default=0)
    
    # Format and combine lines
    result = []
    for time, text in lines:
        text = text.strip()
        if text:
            timestamp = format_timestamp(time)
            result.append(f"{timestamp} {text}")
    
    return "\n".join(result)


def process_m4a_file(filename, mode):
    with open(filename, "rb") as f:
        file_size = f.seek(0, 2)
        f.seek(0)

        moov_end, _ = find_atom(f, file_size, "moov")
        if not moov_end:
            error_exit("error: 'moov' atom not found")

        trak_end, _ = find_atom(f, moov_end, "trak")
        if not trak_end:
            error_exit("error: 'trak' atom not found")

        udta_end, _ = find_atom(f, trak_end, "udta")
        if not udta_end:
            error_exit("error: 'udta' atom not found")

        tsrp_end, header_size = find_atom(f, udta_end, "tsrp")
        if not tsrp_end:
            error_exit("error: 'tsrp' atom not found")

        current_pos = f.tell()
        data_size = tsrp_end - current_pos
        tsrp_data = f.read(data_size)

        if mode == "raw":
            sys.stdout.buffer.write(tsrp_data)
            return

        json_obj = {}
        try:
            json_obj = json.loads(tsrp_data.decode("utf-8"))
        except Exception:
            error_exit("error: could not parse transcript data")

        if mode == "json":
            json.dump(json_obj, sys.stdout, ensure_ascii=False, separators=(",", ":"))
            print()
            return
        
        if mode == "timestamps":
            result = extract_text_with_timestamps(json_obj)
            if result:
                print(result)
            return

        printed = False
        attributedString = json_obj.get("attributedString")
        if isinstance(attributedString, list):
            for item in attributedString:
                if isinstance(item, str):
                    print(item, end="")
                    printed = True
        elif isinstance(attributedString, dict):
            for item in attributedString.get("runs", []):
                if isinstance(item, str):
                    print(item, end="")
                    printed = True
        if printed:
            print()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Extract transcript data from Apple Voice Memos .m4a files."
    )
    parser.add_argument("filename", help="path to the .m4a file")
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--text", action="store_true", help="print transcript as plain text (default)"
    )
    group.add_argument(
        "--json", action="store_true", help="print transcript data as JSON"
    )
    group.add_argument("--raw", action="store_true", help="print raw transcript data")
    group.add_argument(
        "--timestamps", action="store_true", help="print transcript with timestamps"
    )
    args = parser.parse_args()

    if args.json:
        mode = "json"
    elif args.raw:
        mode = "raw"
    elif args.timestamps:
        mode = "timestamps"
    else:
        mode = "text"

    process_m4a_file(args.filename, mode=mode)
